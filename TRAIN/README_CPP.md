![C++ Logo](logoCPP.png)[^1]

[^1]: © 2017 Jeremy Kratz and The Standard C++ Foundation.

# C++

The [main README](../README.md) sits in the parent directory.

Please see the [train README](README.md) for the general methods and algorithms used for training.

According to Bjarne Stroustrup:

> "C++ is for people who want to use hardware really well and then manage the complexity of doing that through abstraction."

Here are my own interpretation of some C++17 idioms and practices used in this project.

---

## License

*All trademarks are the property of their respective owners.*

Copyright 2022 Nicolas Chaussé (nicolaschausse@protonmail.com)

    This project is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, version 3 of the License only.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.

---

## Build with C++17

The build environment for this project is rather simple, is wholly coded in [GNU Bash](https://www.gnu.org/software/bash) and is made of 10 scripts.

* ***analyze.sh*** analyzes the C++ source file provided with [Cppcheck](http://cppcheck.net) and [clang-tidy](https://clang.llvm.org/extra/clang-tidy).
* ***build.sh*** simply calls *compile.sh* then *analyze.sh* with the C++ source file provided.
* ***compile.sh*** compiles the C++ source file provided with multiple versions of [GNU g++](https://gcc.gnu.org) and [LLVM clang++](https://clang.llvm.org), to help debug complex compilation problems and allow to performance-test multiples compilers.
* ***documentAll.sh*** invokes documenter [Doxygen](https://www.doxygen.nl) with parameter file **Doxyfile**.
* ***executablesDelete.sh*** simply deletes all the executables generated by *compile.sh* and *run.sh*.
* ***executablesList.sh*** simply lists all the executables generated by *compile.sh* and *run.sh*.
* ***flags.sh*** defines in a single file **all** compile, warnings, analyze and tidy flags and is sourced by *analyze.sh*, *compile.sh* and *run.sh*.
* ***formatAll.sh*** *clang-formats* all .cpp and .hpp C++ source files with stype *Mozilla*.
* ***include.sh*** simply defines a few utilities and is sourced by other scripts.
* ***run.sh*** compiles the C++ source file provided with only one compiler then, if no error occurs, runs the corresponding executable.

### Install LLVM Tools and Clang++

Clang and LLVM tools are not installed by default on many platforms, one can install them through the following [APT packages](https://apt.llvm.org). For versions 13, 14 and 15: `clang-<version> clang-format-<version> clang-tidy-<version> clang-tools-<version> llvm-<version> llvm-<version>-tools lld-<version>`.

### Warning Flags

Compilers nowadays provide many useful warnings, that shall be overlooked only very purposefully. The following shall always be enabled in this project:

* `-Wpedantic`, `-Wall`, and `-Wextra`.
* For LLVM: `-Weverything` (plus `-Wno-c++98-compat`, `-Wno-c++11-compat` and `-Wno-c++14-compat'`).

### Compile Flags

For maximum performances when not debugging, the following shall be enabled:

* `-O3`, `-g0` and `-DNDEBUG`.
* `-pedantic-errors`.
* `-march=native` and `-mtune=native`. This implies recompiling on **all** platforms as this may generate executables that are not very portable.
* Disabling link-time optimization with `-fno-lto` will in some conditions increase performances and should be tested.

### Static Code Analysis

[Cppcheck](http://cppcheck.net) comes quite usable as is and the latest version can easily be git-cloned and compiled, and then called with flag `-enable=all`:

```
$ cd <package directory of your choice>
$ git clone https://github.com/danmar/cppcheck.git
$ cd cppcheck
$ export CXX='clang++-14'  # Optional, compiler of your choice.
$ make
$ ./cppcheck --enable=all program.cpp
```

[clang-tidy](https://clang.llvm.org/extra/clang-tidy) needs much more flags, and different versions will sometimes output slightly different results. This is why ***analyze.sh*** above calls two versions of it. This project uses many *groups of checks* including:

* `cert-*` to enforce [CERT Secure Coding Guidelines](https://wiki.sei.cmu.edu/confluence/display/seccode/SEI+CERT+Coding+Standards).
* `clang-analyzer-*` to enable clang's static analyzer checks.
* `concurrency-` to check the multithreading.
* `performance-` to check for performance.

See ***flags.sh*** for more details.

---

## Some C++17 Features and Idioms

What follows is a list of some C++17 features and how they shall be employed in this project.

### `decltype(auto)` and `auto`

As much as possible, except for copy and move assignment operators, function return types shall be one of:

* `void`,
* `bool`,
* `decltype(auto)`.

Initialized variables shall be declared as `auto`.

### Exceptions

`assert` shall never be called and exceptions shall be thrown on ***all*** unrecoverable errors, in case the caller wants to recover, save some states (e.g. the current weights), or cleanup the stack before propagating the (by definition exceptional) failure. `static_assert()` shall be used to validate conditions at compile time.

Exceptions shall ***never*** happen only from user inputs and shall always mark a bug or an issue internal to the program.

Although exceptions are technically very low cost at run time, functions that have to be optimized shall be declared `noexcept` as much as possible.

### Move Semantics

In functions, *rvalue references* may need to be passed via `std::move()` when passed down to other functions, e.g.:

```c++
// f() is called with an rvalue reference.
void f(Type&& x)
{
  // x is an lvalue reference here.
  g(x);             // x is still needed.
  h(std::move(x));  // x is not needed anymore.
}
```

Also in functions, *forwarding references* may need to be passed via `std::forward<>()` when passed down to other functions, e.g.:

```c++
// Both f(Type&) and f(Type&&) may be instantiated and called.
template<typename Type>
void f(Type&& x)
{
  // x is an lvalue reference here.
  g(x);                      // x is still needed.
  h(std::forward<Type>(x));  // x is not needed anymore.
}
```

### Pointers

The only two occasions where *raw pointers* shall be used is for utilizing `*this` and `main()`'s `argv` argument. Everywhere else, `std::unique_ptr` or `std::shared_ptr` shall be used. `std::unique_ptr` at is pretty much zero-cost at run time while `std::shared_ptr` is very low cost. They both solve the problem of shared objects deallocation and a collection of them can be gathered in a `std::vector`. As much as possible, smart pointers will only be created via `std::make_unique` and `std::make_shared`.

### RAII (Resource Acquisition is Initialization)

RAII shall be used to lock mutexes so to guarantee they get unlocked.

```c++
  std::mutex myMutex;
  ...
  // Lock guard context.
  {
    std::lock_guard const lockGuard(myMutex);
    ...
  }
```

Also, a local `struct` can be declared in a function to guarantee the deallocation of some resources, irrespective of how the functions returns or if exceptions are thrown (and caught downstream). Because of its ephemeral nature, such a `struct` does not need to follow the [rule of five](https://en.cppreference.com/w/cpp/language/rule_of_three). For example, the following will **always** print 3:

```c++
void f(int& x)
{
  struct Deallocator {
    int& deallocator_x;
    Deallocator(int& constructor_x) : deallocator_x(constructor_x) { }
    ~Deallocator() { deallocator_x = 3; }
  } deallocator(x);

  srand(time(nullptr));
  if (rand() % 2) { x = 1; return; }
  if (rand() % 2) { throw true; }
  x = 2;
}
int main()
{
  int a;
  try { f(a); }
  catch (...) { }
  std::cout << a << '\n';
}
```

### Range-based For Loop

If the range's values need to be modified, then a *forwarding reference* shall be used:

```c++
  for (auto&& element : collection)
    ++element;
```

Otherwise, if the range's values need only be read, a *const reference* shall be used as it can almost be viewed as a read-only "universal reference":

```c++
  for (auto const& element : collection)
    std::cout << element;
```

---

## Templated Code Proliferation

Templated coded may, under some circumstances, be instantiated *en masse* if left unchecked. The four following habits shall therefore be implemented (knowing that compilers may nonetheless inline some code).

#### 1. De-templatize common code, e.g.:

```c++
void common()
{
  ...
}

template<typename Type>
void f(Type&& x)
{
  g(std::forward<Type>(x));
  common();
}
```

#### 2. When calling templated functions, *decay* C strings to type `char*` by prefixing them with `+`:

All C string types can be passed to functions by implicitly converting them on the fly to a `std::strings` as follows:

```c++
void f(std::string const& name)
{
  ...
}

f("Hello");
char s[100]{ "Ciao" };
f(s);
```

This has the disadvantage of creating and destroying on the stack a `std::string` each and every time `f()` is called. To save this run time cost, one may be tempted to templatize `f()` thus, so to forward C strings and `std::strings` as is:

```c++
template<typename String>
void f(String const& name)
{
  ...
}
```

Unfortunately this will lead to templated code proliferating as, according to [C++ Insights](https://cppinsights.io/), the following will instantiate `f()` **six** times to handle C strings only:

```c++
template<typename String>
void f(String const& name)
{
  ...
}

int main()
{
  f("Hello");             // (1) Instantiates 'f<char [6]>'.
  f("Hola");              // (2) Instantiates 'f<char [5]>'.
  f("Bonjour");           // (3) Instantiates 'f<char [8]>'.
  char s1[10]{ "Ciao" };
  f(s1);                  // (4) Instantiates 'f<char [100]>'.
  auto s2{ "Buna ziua" };
  f(s2);                  // (5) Instantiates 'f<const char *>'.
  char* s3{ s1 };
  f(s3);                  // (6) Instantiates 'f<char *>'.

  f(std::string("Olá"));  // Instantiates 'f<std::basic_string<char>>'.

  f(+"Hello");            // Uses 'f<const char *>'.
  f(+"Hola");             // Uses 'f<const char *>'.
  f(+"Bonjour");          // Uses 'f<const char *>'.
  f(+s1);                 // Uses 'f<char *>'.
}
```

Therefore, when calling templated functions, *decay* C strings to type `char*` by prefixing them with `+`.

#### 3. When this can not be controlled and C strings and `std::string` need only to be passed through, define the three following functions:

```c++
template<typename String>
void original_f(String const& name)
{
  ...
}

void f(char const* const name)
{
  original_f(name);  // Instantiates 'original_f<const char *>'.
}
void f(char* const name)
{
  // Cast name to 'char const*' to use 'original_f<const char *>'.
  original_f(static_cast<char const*>(name)); 
}
template<typename String>
void f(String const& name)
{
  original_f(name);
}
```

This will instantiate `original_f()` only **once** to handle all C strings.

#### 4. When a `std::string` needs to be retained could be moved from, define the following two functions:

```c++
void f(std::string&& s)
{
  my_s = std::move(s);
}
void f(std::string const& s)
{
  f(std::string(s));
}
```

The first `f()` will catch all C strings, that will be implicitly converted on the stack to r-value `std::strings` that will be moved from. The second `f()` will catch actual l-value `std::strings`, duplicate them to r-value `std::strings` and pass them to the first `f()`. The first `f()` will also catch anything at all that can be implicitly converted to a `std::string`.

---

## Type Erasure

***Type Erasure*** in C++ is a powerful pattern used to readily add new functionality to a set of unrelated already existing classes, without having to re-open or edit said classes. These classes are encapsulated and their original types can be considered *erased* as only the newly defined behaviour remains accessible. This pattern also handles the lifetime of the underlying type-erased objects.

The following was inspired by [Klaus Iglberger](https://github.com/igl42)'s interpretation. One way to implement such a pattern is to use *Mixins* to define this new functionality as a *Strategy*, instead of using free floating functions. To do so:

#### 1. Gather a number of unrelated classes, e.g.:

```c++
class Object1
{
  ...
public:
  void a(int x) { ... }
  void b(int x) { ... }
};
class Object2
{
  ...
public:
  void c(int x) { ... }
  void d(int x) { ... }
};
```

#### 2. Define a set of functions in a Mixin to implement a new Strategy for each class selected above. Optionally, define the same set of functions in more than one such Mixin to implement different Strategies, e.g.:

```c++
class StrategyA
{
protected:
  void f1(Object1& o, int x) { o.a(x); }
  void f2(Object1& o, int x) { o.a(x); o.b(x); }

  void f1(Object2& o, int x) { o.d(x); o.c(x); }
  void f2(Object2& o, int x) { o.d(x); }
};
class StrategyB
{
protected:
  void f1(Object1& o, int x) { o.b(x); }
  void f2(Object1& o, int x) { o.a(x); }

  void f1(Object2& o, int x) { o.d(x); }
  void f2(Object2& o, int x) { o.c(x); }
};
```

#### 3. Copy and paste the following ***Type Erasure*** idiom with the following modifications:

First, for each function name above, determine a corresponding helper function name, e.g.: `ff1` for function `f1()`, `ff2` for function `f2()`, etc.

Then essentially:

1. In the interface, declare each helper function as `virtual pure`.
1. In the templated implementation, define each helper function to call its counterpart function.
1. In the class definition, define functions to call each its counterpart helper function.

More specifically, for each pair `<function>` and `<helper>`:

1. In `struct Interface` right under `// Virtual interface.`, declare: `virtual <return type> <helper>(...) = 0`.
1. In `struct Implementation`, right under `// Implemented interface.`, define: `<return type> <helper>(...) override { this-><function>(myObject, ...); }`.
1. At the bottom of the class definition, right under `// Strategy.`, define: `<return type> <function>(...) { pimpl-><helper>(...); }`.

Resulting in:

```c++
template<typename Strategy>
class TypeErased
{
private:
  struct Interface
  {
    // Virtual default destructor.
    virtual ~Interface() = default;

    // Virtual interface.
    virtual void ff1(int x) = 0;
    virtual void ff2(int x) = 0;
  };

  template<typename MyObject>
  struct Implementation : public Interface, public Strategy
  {
    MyObject myObject;
    template<typename Object>
    Implementation(Object&& object)
      : myObject(std::forward<Object>(object)) { }

    // Implemented interface.
    // 'this->' needed here to access templated superclass Strategy.
    void ff1(int x) override { this->f1(myObject, x); }
    void ff2(int x) override { this->f2(myObject, x); }
  };

  std::unique_ptr<Interface> pimpl;

public:
  template<typename Object>
  TypeErased(Object&& object)
    : pimpl(std::make_unique<Implementation<std::decay_t<Object>>>
      (std::forward<Object>(object)))
  { }

  // Strategy. ONLY this is exposed.
  void f1(int x) { pimpl->ff1(x); }
  void f2(int x) { pimpl->ff2(x); }
};
```

So this can be used as follows:

```c++
int main()
{
  TypeErased<StrategyA> te1((Object1()));
  Object1 o2;
  TypeErased<StrategyB> te2(o2);
  te1.f2(1);
  te2.f1(2);

  std::vector<TypeErased<StrategyA>> objects;
  objects.emplace_back(Object1());
  objects.emplace_back(Object2());
}
```

Although this represent lots of code, modern compilers *should* compile away most of it.

---

## Compound Strategies to Existing Objects

The main drawback with *Type Erasure*'s interpretation above is that the original type-erased functionality is lost forever and that the original objects can only be copied/moved from. A more general solution would be to be able to compound new Strategies to existing objects as well, and to retain full access to said existing objects. Using the same definitions for `Objects` and `Strategies` as under **Type Erasure** above, we would be able to do:

```c++
int main()
{
  Compounded<StrategyA> c1((Object1()));
  auto o1{ std::make_shared<Object1>() };
  Compounded<StrategyA> c2(o1);
  Compounded<StrategyB> c3(o1);

  c1.f1(1);
  c2.f1(2);
  o1->b(3);
  c3.f1(2);
}
```

Templated class `Compounded` below gets a constructor that detects if the passed object is a `std::shared_ptr` and stores it in the pimpl accordingly.

```c++
template<typename Strategy>
class Compounded
{
private:
  struct Interface
  {
    // Virtual default destructor.
    virtual ~Interface() = default;

    // Virtual interface.
    virtual void ff1(int x) = 0;
    virtual void ff2(int x) = 0;
  };

  template<typename MyObject>
  struct Implementation : public Interface, public Strategy
  {
    std::shared_ptr<MyObject> myObjectPointer;
    template<typename ObjectPointer>
    Implementation(ObjectPointer&& objectPointer)
      : myObjectPointer(std::forward<ObjectPointer>(objectPointer))
    { }

    // Implemented interface.
    // 'this->' needed here to access templated superclass Strategy.
    void ff1(int x) override { this->f1(*myObjectPointer, x); }
    void ff2(int x) override { this->f2(*myObjectPointer, x); }
  };

  std::unique_ptr<Interface> pimpl;

  // Used by the constructor below.
  template<typename Type> struct is_shared_ptr : std::false_type {};
  template<typename Type> struct is_shared_ptr<std::shared_ptr<Type>> : std::true_type {};

public:
  template<typename Object>
  Compounded(Object&& object)
  {
    // object is a shared_ptr so pass it as is to make_unique.
    if constexpr (is_shared_ptr<std::decay_t<Object>>::value) {
      pimpl = std::make_unique<Implementation<typename std::decay_t<Object>::element_type>>
              (std::forward<Object>(object));
    // object is NOT a shared_ptr so make a shared_ptr of it and pass it up.
    } else {
      pimpl = std::make_unique<Implementation<std::decay_t<Object>>>
              (std::make_shared<std::decay_t<Object>>(std::forward<Object>(object)));
    }
  }

  // Strategy. ONLY this is exposed.
  void f1(int x) { pimpl->ff1(x); }
  void f2(int x) { pimpl->ff2(x); }
};
```

I can see two drawbacks to this approach:

1. The type-erased object can **not** itself be a `std::shared_ptr`.
1. The type-erased object is stored in a `std::shared_ptr` and not directly, adding a second level of indirection, thus slightly hurting performance.

The main advantage would be that no `clone()` method is needed as compounded objects can be created at will from the original objects.

---